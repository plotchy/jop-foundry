// SPDX-License-Identifier: MIT
// solhint-disable-next-line
pragma solidity 0.7.6;

import "ds-test/test.sol";
import "../myExploit.sol";

interface CheatCodes {
    function prank(address) external;
    function deal(address, uint) external;
    function load(address account, bytes32 slot) external returns (bytes32);
    function record() external; // Record all storage reads and writes
    function accesses(address) external returns (bytes32[] memory reads, bytes32[] memory writes); // Gets all accessed reads and write slot from a recording session, for a given address
    function store(address account, bytes32 slot, bytes32 value) external;
}

contract myExploitTest is DSTest {
    CheatCodes cheats = CheatCodes(HEVM_ADDRESS);
    myExploit exploit;
    event testAddress(address);
    function setUp() public {
        emit testAddress(address(this));
        exploit = new myExploit{value:51 ether}();
        // cheats.record();
        // exploit.setup().isSolved();
        // cheats.accesses(address(exploit.challengeInterface()));
        //This is used in order to understand the storage slots that are used for the challenge
    }

    function testSanityCheck() public {
        //Note that the owner() slot is shared with a uint8, so shift the owner address left by 1 byte
        cheats.store(exploit.challengeAddress(), hex"0000000000000000000000000000000000000000000000000000000000000005", hex"0000000000000000000000deaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD00");
        cheats.store(exploit.challengeAddress(), hex"3c11f783dbd1ff293f3b738beb958568cd23e3f7bb0f5efcb90a240ffdf4d550", hex"0000000000000000000000000000000000000000000000000000000000000000");
        cheats.deal(exploit.challengeAddress(), 0);
        assertTrue(exploit.setup().isSolved() == true);
    }

    event bytes32Emitter(bytes32);
    function testStep1() public {
        cheats.record();
        exploit.step1();
        (bytes32[] memory reads, bytes32[] memory writes) = cheats.accesses(address(exploit.challengeInterface()));
        bytes32 slotVal = cheats.load(exploit.challengeAddress(), bytes32(uint256(0x0b)));
        assertTrue(slotVal == hex"00000000000000000000000000000000000000000000000000000000000019fc");
        assertTrue(writes[0] == hex"000000000000000000000000000000000000000000000000000000000000000b");
    }

    function testStep2() public {
        exploit.step1();
        // cheats.record();
        exploit.step2();
        // cheats.accesses(address(exploit.challengeInterface()));
        assertTrue(exploit.setup().isSolved() == true);
        // bytes32 slotVal = cheats.load(exploit.challengeAddress(), bytes32(uint256(0x0b)));
        // assertTrue(slotVal == hex"00000000000000000000000000000000000000000000000000000000000019fc");
        // assertTrue(writes[0] == hex"000000000000000000000000000000000000000000000000000000000000000b");
    }


}
