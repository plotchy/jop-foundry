// SPDX-License-Identifier: MIT
// solhint-disable-next-line
pragma solidity 0.7.6;
// pragma abicoder v1; //this is active by default in Solidity <0.8.x


import "./mySetup.sol";

contract myExploit {



    address payable public challengeAddress;
    address payable public setupAddress;
    ChallengeInterface public challengeInterface;
    mySetup public setup;

    constructor() payable {
        require(msg.value == 51 ether);
        setup = new mySetup{value: 50 ether}();
        setupAddress = payable(address(setup));
        challengeAddress = setup.challengeAddress();
        challengeInterface = ChallengeInterface(challengeAddress);
    }

    function step1() public {
        //This function will store the 19fc into the 11th storage slot
        bytes memory step1Data = hex"27f8335000000000000000000000000000000000000000000000000000000000000019fc";
        // solhint-disable-next-line
        challengeAddress.call(step1Data);
    }

    function step2() public {
        //This function needs to pass a payload that will change the owner, transfer out the ETH, and burn the erc20 tokens that setup has 
        /*
        label_1CB2 has the error in jump destination
        tx.gasprice < 0x2e90edd000
        Note that you don't have to pass the msg.sender check, instead we can pass the storage[0x09 < storage[0x0a]] check
            We can find out what each of these are through:
                ✅ using cheatcode load() to find out
                ✅ searching for PUSH1 0x09 / PUSH1 0x0a followed by SSTORE and working out how to inc/dec these values

        ✅ label 1cb2 entered with stack[0] = 0xed0, stack[1] = 0x0774, stack[2] = 0xd0febe4c
        label 1d0f entered same way (8C6s)
        all arranged for 19fc jump, enter with stack[0] = msg.value, 1=1d39, 2=ed0, 3=0774, 4=d0febe4c
            the first dup9 will dup msg.value
        2nd word > 0
        3rd word > 0
        4th word < massive uint256 AND (if <27, += 27)

        words get rearranged on stack 4,3,2,1
        first iteration is different than all others, this is due to use carrying over a 1d
            1 = value, 2 = 19fc, 3=next iter calldata offset, 4=19fc
        second+on iterations can be:
            1 = value, 2 = value, 3=19fc, 4=next iter calldata offset (prev+80)

        For both of these strategies, as long as 2nd>0, we won't have to worry about any of the restrictions

        Your first time through, you still have the 1d39 on the stack, which jumps you to a jumpdest->Jump next step (consuming the 19fc)
        Next time around, the 2nd word you originally had is in the place of the 1d39 slot, so making that a 19fc will jump to the right place
        For all future iterations, the 3rd word will be read for the jump, and the 4th read will be read for the offset, letting us stack 2 words per iter
        
        Note that our second to last iteration's 3rd word should jump to where we want after building the stack
        The last iteration can completely be what we want to set on top of the stack
        
        */
        
        bytes memory iter1 = hex"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000019fc000000000000000000000000000000000000000000000000000000000000008400000000000000000000000000000000000000000000000000000000000019fc";
        bytes memory iter2 = hex"0000000000000000000000000000000000000000000000000000000000000366000000000000000000000000000000000000000000000000000000000000036600000000000000000000000000000000000000000000000000000000000019fc0000000000000000000000000000000000000000000000000000000000000104";
        bytes memory iter3 = hex"000000000000000000000000037fc82298142374d974839236d2e2df6b5bdd8f000000000000000000000000000000000000000000000a7b667f19c28bf0000000000000000000000000000000000000000000000000000000000000000019fc0000000000000000000000000000000000000000000000000000000000000184";
        bytes memory iter4 = hex"00000000000000000000000000000000000000000000000000000000000017E90000000000000000000000001111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000102a0000000000000000000000000000000000000000000000000000000000000204";
        bytes memory iter5 = hex"000000000000000000000000000000000000000000000002b5e3af16b1880004000000000000000000000000000000000000000000000000000000000000191b0000000000000000000000000000000000000000000000000000000000000c4a000000000000000000000000deaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD";
        bytes memory altogether = abi.encodePacked(hex"d0febe4c", iter1, iter2, iter3, iter4, iter5);
        challengeAddress.call{value: 0x04}(altogether);

        /*
        1. Our first challenge to pass can be ownership.
        Looking at acceptOwnership(), the slot 5 becomes the slot 6(owner), so we first need to store deaddead into slot 5.
            This is done is transferOwnership()
        081e - start of transferOwnership
            Issue here is we don't pass a storage value check
        102A, occurs after msg.sender check with storage0x05
            I believe this works great with 0xdead as the last element of the payload
            Next element will be jump to next step
        (8C37s)

        Now that deaddead is stored, we need to accept that ownership
        Seems smart to find this by looking for PUSH1 0x06
        0B87 - seems to be msg.sender check against 0x06
        0C4A - seems to be place where slot 5 is moved into slot 6
            next jump is next stack item



        2. Next challenge is to transfer out ETH
        Looking for any CALL's in the code, there is exactly one, taking place after:
        191B - stack[-1] = transferValue, stack[-2] = address
            transferValue = 50 ether + 4 wei = 2b5e3af16b1880004
            address = 0x1111111111111111111111111111111111111111
        
        return data matters here for control flow afterwards, using a nonEOA address is what I'll look at first (returndata = 0x0)
            we do eventually get a jump from our stack. There are a lot of pops on the way that will take our items
            actually, all the pops are for the opcode added pushes and successes. As long as the call succeeds(it will) we jump to value 8

        3. The last challenge is to drain the erc20 tokens that setup has
            from looking at setup.isSolved with record() and accesses() we can see this occurs at slot 3c11f783dbd1ff293f3b738beb958568cd23e3f7bb0f5efcb90a240ffdf4d550
            we can use transferFrom() although we'd need approval from setup, which we can probably get
            we can also use _burn()
                This can be hard to find. I know that we'll need to access a mapping, so I can look for where SHA is used
                    There are 28 occurences, so idk about this one
                I also know that a log3 is used to report the Transfer() event, and that the event contains 0x0 as the address
                    There are 4 occurences of this, so it could work
            1263 could work. Seems like value (stack1), to(stack3) and from(stack2) are controllable, and we jump to stack 4
                Looking at the opcodes, this doesn't seem like any transfer function I know... It looks like it overwrites the balance with the value. It doesn't increase it elsewhere, and it also doesn't force the event to go to 0x0000...
                    This very well could be the _burn function and there is a push1 0x00 preceding this jumpdest. 
                    Looking at previous JUMP above 1263, looks like this is exactly the case. Can only get here if the {to} is 0x0000. 
                        Could be that it is optimized(?) such that _burn and _transfer use the same opcodes, just that _burn is only used if the {to} of _transfer is 0x0000
                stack[1] =0a7b667f19c28bf00000 (49.5 ether), stack[2]=037fc82298142374d974839236d2e2df6b5bdd8f (setup address {from}), stack[3]=1111111111111111111111111111111111111111 (any other address, {to}. can't be 0x0 as it'll fail our payload creation)
            so 1263 appears to be approve()
                I can still transferFrom now, but _burn may still be easier
            18AB appears to be _burn(), i can tell since the log3 outputs a 0x00
                stack[1] gets stored at slot 2
                stack[2] may also be {from} address?
                stack [3] is address {from} 
                This doesn't seem right after thinking, I can only SSTORE to slot 2....
            14D0 possibly
                looks like i can control the slot its stored to and the value
                just need to see if the control flow lets me jump anywhere
                    looks like it still does? Seems like I need to pass a check that looks like currentBalance >= value burnt
                    This may also be checking for allowance rather than amount?
            1563 has it all, SSTORE, LOG3, only issue is you're storing a stack item, so you need to find a way to stack 0
                This is possible but hard. You'd need to store it with value4 in an iteration of loadSignature(). This can be done by finding a JUMPDEST->JUMP to have the location of your values be placed
                    in a way that the 0 is in the 4th word.
                    ie: use "ede" repeatedly (gut feel says 2 times?) to 'slide' the stacked value into the 4th word

            I cheated and looked at the solution 
            1757
                I think I can actually make a deeper solution work
                17E9
                    1895 is the magic moment of the sstore
                        cant go directly to the 1895 block as you need a 0 to be stack1
                learning experience, there is nothing that stands out about 1757 or 17E9. The only hint is that you know you "return to 0x0b27", and that it was just pushed before jumping there, which we know our stack items will override
                    17E9 doesn't have an SSTORE or a LOG3, but things following it do.
                    This is really hard to find, you would need to work quite a ways backwards from the SSTORE in 1895. Makes it harder as the 1895 block needs to stack as [0, value, address]
                        and we can't place 0s due to the loadSignature() restriction 
                If I did this again, I'd go the 1563 route and do the sliding approach to store a 0 on the stack.





        With all the challenges done, find a JUMPDEST with a STOP
            0366 works

        
        
        */

    }


    function checkSolved() public view returns (bool) {
        return setup.isSolved();
    }
}